Copyright © Martin H. Sharp; August 2025

Instruction Set Architecture (ISA) of EC72(Emulator CPU 72) Documentation



Concept:
Inspired by a 1972 experimental microcontroller with CALL/RET stack support, a small register file, and a RISC-style fixed-length instruction set — but with a tiny 256-word memory for cost-saving.

1. Registers
Name	Size	Description
RA	8-bit	Accumulator A (primary ALU operand)
RB	8-bit	General-purpose register B
RC	8-bit	General-purpose register C
RE	8-bit	General-purpose register E
SP	8-bit	Stack Pointer (defaults to 0xFF, grows downward)
IR	16-bit	Instruction Register (current instruction)
PC	8-bit	Program Counter
MAR	16-bit	Memory Address Register
STOFR	8-bit	Stack Overflow Register (just stores the address of when the overflow happens)
STUFR	8-bit	Stack Underflow Register (just stores the address of when the underflow happens)


1.2 Register Encoding
Name	Code
RA	0x01
RB	0x02
RC	0x03
RE	0x04
SP	0x05



2. Flags
Flag	Description
ZF	Zero Flag — Set if result == 0
NF	Negative Flag — Set if result < 0
OF	Overflow Flag — Set if result > 255 or < 0



3. Memory

    256 memory locations, addresses 0x00–0xFF.

    Each location is a 16-bit word.

    Stack grows downward from SP (default 0xFF).
    
    the STOFR and the STUFR store when the over- or underflow happends, and thus define the stack size

    Top stack area often used for local variables.




4. Instruction Format

    16-bit word per instruction:

        High byte = Opcode (8 bits)

        Low byte = Operand (8 bits)

    Format: [ OPCODE ][ OPERAND ]




5. Instructions

5.1 Data Movement
Mnemonic	Opcode	Format	Description
MOVR d s	0x01	d=hi nibble,	Move from register s to register d
			s=lo nibble	
MOVA addr	0x02	addr (8-bit)	Load mem[addr] → RA
MOVB addr	0x03	addr		Load mem[addr] → RB
MOVC addr	0x04	addr		Load mem[addr] → RC
MOVE addr	0x05	addr		Load mem[addr] → RE
STORA addr	0x06	addr		Store RA → mem[addr]
STORB addr	0x07	addr		Store RB → mem[addr]
STORC addr	0x08	addr		Store RC → mem[addr]
STORE addr	0x09	addr		Store RE → mem[addr]
LDIMA imm	0x0A	imm		Load immediate imm → RA
LDIMB imm	0x0B	imm		Load immediate imm → RB
LDIMC imm	0x0C	imm		Load immediate imm → RC
LDIME imm	0x0D	imm		Load immediate imm → RE
MOVA_PTRB	0x19	None		Load RA from mem[RB]
STORA_PTRB	0x1A	None		Store RA → mem[RB]


5.2 Stack opreations
Mnemonic	Opcode	Format	Description
PUSH reg	0x1B	reg_code	SP--, store reg at mem[SP]
POP reg		0x1C	reg_code	Load mem[SP] → reg, SP++
ADDSP imm	0x1D	imm	SP += imm (no flags)
SUBSP imm	0x1E	imm	SP -= imm (no flags)
SSTOF addr	0x1F	addr	Sets STOFR should be ideally done at boot
SSTUF addr	0x20	addr	sets STUFR should be ideally done at boot NOT later, additional it overwrites the SP with Operand

5.2 Control Flow
Mnemonic	Opcode	Format	Description
JMPN addr	0x0E	addr	Jump if NF=1
JMPZ addr	0x0F	addr	Jump if ZF=1
JMPO addr	0x10	addr	Jump if OF=1
JMP addr	0x11	addr	Unconditional jump
CALL addr	0x17	addr	Push PC, jump to addr
RET		0x18	None	Pop PC from stack

5.3 Arithmetic / Logic
Mnemonic	Opcode	Format	Description
ADD imm		0x12	imm	RA += imm (sets flags)
SUB imm		0x13	imm	RA -= imm (sets flags)
ADDR reg	0x14	reg_code	RA += reg (sets flags)
SUBR reg	0x15	reg_code	RA -= reg (sets flags)


5.4 I/O & Halt
Mnemonic	Opcode	Format	Description
OUT		0x16	None	Output RA to console
HLT		0xFF	None	Halt execution




6. Stack Behavior

    PUSH reg: SP--, store reg into mem[SP]

    POP reg: Load mem[SP] into reg, SP++

    CALL addr: Push PC, set PC=addr

    RET: Pop PC from stack

    ADDSP/SUBSP: Adjust SP without affecting flags


7. Flag Updates

    Affected by: ADD, SUB, ADDR, SUBR

    Rules:

        ZF: result == 0

        NF: result < 0

        OF: result > 255 or < 0 (wraps at 8-bit)



Example Encodings
Instruction	Hex
LDIMA 5		0x0A05
MOVR RE RB 	0x0142
MOVR RA RC	0x0113
JMPZ 0x10	0x0F10
ADD 3		0x1203
CALL 0x0B	0x170B
PUSH RA		0x1B01
ADDSP 2		0x1C02



Execution Model

    Fetch: IR = memory[PC], PC++

    Decode: Opcode (IR>>8), Operand (IR & 0xFF)

    Execute: Perform operation as defined by opcode

    Update Flags (for ALU operations)

    Repeat




Summary:

This ISA is a simple 8-bit architecture with:

    4 general-purpose registers (RA, RB, RC, RE)

    Stack support with CALL/RET

    Arithmetic operations

    Basic memory I/O (direct and indirect)

    Conditional and unconditional jumps

    Flag-based conditional execution

    Immediate and memory-based addressing modes.

